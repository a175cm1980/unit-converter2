<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>跑酷小遊戲</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Noto Sans TC', sans-serif;
            background: linear-gradient(135deg, #f0f4f8, #cdd7e1);
            color: #333;
            text-align: center;
            padding: 20px;
        }

        .game-container {
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            display: inline-block;
            max-width: 90%;
            width: 500px;
            box-sizing: border-box;
        }

        h1 {
            font-weight: 700;
            color: #2c3e50;
            font-size: 2.5em;
            margin-top: 0;
        }

        .stats-container {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            font-size: 1.2em;
            font-weight: 400;
        }
        .stats-container p {
            margin: 0;
            padding: 5px 15px;
            background-color: #e8f0f7;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #gameCanvas {
            background-color: #a4e6ff;
            border: 3px solid #34495e;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            display: block;
            width: 100%;
            aspect-ratio: 1 / 2;
        }

        #gameStatus {
            margin-top: 20px;
            font-size: 1.6em;
            font-weight: 700;
            color: #e74c3c;
            min-height: 40px;
        }

        .button-container {
            margin-top: 20px;
        }

        #startButton {
            padding: 12px 25px;
            font-size: 1.2em;
            font-weight: 700;
            cursor: pointer;
            background: linear-gradient(180deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #startButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.25);
        }

        #startButton:active {
            transform: translateY(0);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>跑酷小遊戲</h1>
        <div class="stats-container">
            <p>關卡: <span id="level">1</span></p>
            <p>已通過障礙物: <span id="obstaclesPassed">0</span> / <span id="totalObstacles">10</span></p>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="gameStatus">使用鍵盤左右鍵移動，點擊開始遊戲</div>
        <div class="button-container">
            <button id="startButton">開始遊戲</button>
        </div>
    </div>

    <script>
        window.onload = function() {
            // 取得 HTML 元素
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const startButton = document.getElementById('startButton');
            const levelDisplay = document.getElementById('level');
            const obstaclesPassedDisplay = document.getElementById('obstaclesPassed');
            const totalObstaclesDisplay = document.getElementById('totalObstacles');
            const gameStatus = document.getElementById('gameStatus');

            // 遊戲參數
            let gameInterval;
            let obstacleGenerationInterval;
            let obstacles = [];
            let isGameRunning = false;
            let playerSpeed = 5;
            let bombBlastRadius = 100; // 炸彈爆炸半徑
            const explosionDuration = 3000; // 爆炸動畫持續時間（毫秒）

            // 玩家物件
            const player = {
                x: 0,
                y: 0,
                width: 30,
                height: 50,
                dx: 0
            };

            // 關卡與分數
            let currentLevel = 1;
            let passedObstaclesCount = 0;
            let obstaclesPerLevel = 10;
            let obstacleSpeed = 2;
            let obstacleGenerationRate = 1200;

            // 調整畫布尺寸以適應容器
            function resizeCanvas() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetWidth * 2;
                player.x = (canvas.width / 2) - (player.width / 2);
                player.y = canvas.height - player.height - 20;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // 繪製玩家 (優化後的人形)
            function drawPlayer() {
                const headColor = '#2c3e50';
                const bodyColor = '#3498db';
                const limbColor = '#2c3e50';

                const headRadius = player.width * 0.3;
                const bodyWidth = player.width * 0.4;
                const bodyHeight = player.height * 0.4;
                const limbWidth = player.width * 0.2;
                const limbLength = player.height * 0.35;

                // 頭部
                const headX = player.x + player.width / 2;
                const headY = player.y + headRadius;
                ctx.fillStyle = headColor;
                ctx.beginPath();
                ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
                ctx.fill();

                // 身體
                const bodyX = player.x + (player.width - bodyWidth) / 2;
                const bodyY = headY + headRadius;
                ctx.fillStyle = bodyColor;
                ctx.fillRect(bodyX, bodyY, bodyWidth, bodyHeight);

                // 左腳
                const leftLegX = player.x + player.width * 0.2;
                const leftLegY = bodyY + bodyHeight;
                ctx.fillStyle = limbColor;
                ctx.fillRect(leftLegX, leftLegY, limbWidth, limbLength);

                // 右腳
                const rightLegX = player.x + player.width * 0.6;
                const rightLegY = bodyY + bodyHeight;
                ctx.fillStyle = limbColor;
                ctx.fillRect(rightLegX, rightLegY, limbWidth, limbLength);

                // 左手
                const leftArmX = player.x + player.width * 0.1;
                const leftArmY = bodyY + bodyHeight * 0.2;
                ctx.fillRect(leftArmX, leftArmY, limbWidth, limbLength * 0.8);

                // 右手
                const rightArmX = player.x + player.width * 0.7;
                const rightArmY = bodyY + bodyHeight * 0.2;
                ctx.fillRect(rightArmX, rightArmY, limbWidth, limbLength * 0.8);
            }
            
            // 繪製爆炸效果
            function drawExplosion(obstacle) {
                const elapsed = Date.now() - obstacle.explosionStartTime;
                const progress = elapsed / explosionDuration;
                if (progress > 1) {
                    return; // 爆炸動畫結束
                }
                
                const radius = bombBlastRadius * progress;
                ctx.beginPath();
                // 爆炸效果現在跟著障礙物移動
                ctx.arc(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 69, 0, ${1 - progress})`; // 橘紅色，並隨時間變淡
                ctx.fill();
            }

            // 繪製障礙物
            function drawObstacle(obstacle) {
                if (obstacle.state === 'exploding') {
                    drawExplosion(obstacle);
                    return;
                }

                switch (obstacle.type) {
                    case 'rock':
                        // 繪製石頭 (不規則形狀)
                        ctx.fillStyle = '#7f8c8d';
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, obstacle.y + obstacle.height);
                        ctx.lineTo(obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height);
                        ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height * 0.4);
                        ctx.lineTo(obstacle.x + obstacle.width * 0.5, obstacle.y);
                        ctx.lineTo(obstacle.x + obstacle.width * 0.2, obstacle.y + obstacle.height * 0.1);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'trap':
                        ctx.fillStyle = '#34495e';
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        switch (obstacle.subtype) {
                            case 'spikes':
                                ctx.fillStyle = '#c0392b';
                                const spikeCount = 5;
                                const spikeWidth = obstacle.width / spikeCount;
                                for (let i = 0; i < spikeCount; i++) {
                                    ctx.beginPath();
                                    ctx.moveTo(obstacle.x + i * spikeWidth, obstacle.y);
                                    ctx.lineTo(obstacle.x + i * spikeWidth + spikeWidth / 2, obstacle.y + obstacle.height / 2);
                                    ctx.lineTo(obstacle.x + (i + 1) * spikeWidth, obstacle.y);
                                    ctx.fill();
                                }
                                break;
                            case 'pit':
                                ctx.fillStyle = '#2c3e50';
                                ctx.beginPath();
                                ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height, obstacle.width/2, 0, Math.PI, true);
                                ctx.fill();
                                break;
                            case 'water':
                                ctx.fillStyle = '#2980b9';
                                ctx.beginPath();
                                ctx.rect(obstacle.x, obstacle.y + obstacle.height * 0.5, obstacle.width, obstacle.height * 0.5);
                                ctx.fill();
                                break;
                            case 'woods':
                                ctx.fillStyle = '#16a085';
                                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                                break;
                        }
                        break;
                    case 'beast':
                        switch (obstacle.subtype) {
                            case 'tiger':
                                ctx.fillStyle = '#f39c12';
                                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                                ctx.fillStyle = '#000000';
                                ctx.beginPath();
                                ctx.moveTo(obstacle.x + obstacle.width * 0.2, obstacle.y);
                                ctx.lineTo(obstacle.x + obstacle.width * 0.3, obstacle.y + obstacle.height);
                                ctx.moveTo(obstacle.x + obstacle.width * 0.5, obstacle.y);
                                ctx.lineTo(obstacle.x + obstacle.width * 0.6, obstacle.y + obstacle.height);
                                ctx.stroke();
                                break;
                            case 'dragon':
                                ctx.fillStyle = '#27ae60';
                                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                                ctx.fillStyle = '#e74c3c';
                                ctx.beginPath();
                                ctx.moveTo(obstacle.x + obstacle.width * 0.5, obstacle.y);
                                ctx.lineTo(obstacle.x + obstacle.width * 0.2, obstacle.y + obstacle.height);
                                ctx.lineTo(obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height);
                                ctx.closePath();
                                ctx.fill();
                                break;
                            case 'lion':
                                ctx.fillStyle = '#e67e22';
                                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                                ctx.fillStyle = '#f1c40f';
                                ctx.beginPath();
                                ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, obstacle.width/2, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                            case 'crocodile':
                                ctx.fillStyle = '#2ecc71';
                                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                                ctx.fillStyle = '#fff';
                                ctx.beginPath();
                                ctx.arc(obstacle.x + obstacle.width * 0.2, obstacle.y + obstacle.height * 0.2, 3, 0, Math.PI * 2);
                                ctx.arc(obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height * 0.2, 3, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                        }
                        break;
                    case 'bomb':
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, obstacle.width/2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(obstacle.x + obstacle.width/2, obstacle.y, 2, 10);

                        ctx.fillStyle = '#fff';
                        ctx.font = '16px Noto Sans TC';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const timeRemaining = Math.ceil(obstacle.fuseTime - (Date.now() - obstacle.spawnTime) / 1000);
                        ctx.fillText(timeRemaining, obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                        break;
                }
            }

            // 障礙物物件
            function createObstacle() {
                const obstacleWidth = Math.random() * 50 + 20;
                const obstacleTypes = ['rock', 'trap', 'beast', 'bomb'];
                const randomType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                
                let obstacle = {
                    x: Math.random() * (canvas.width - obstacleWidth),
                    y: -obstacleWidth,
                    width: obstacleWidth,
                    height: 25,
                    type: randomType,
                    passed: false,
                    dx: 0,
                    subtype: '',
                    state: 'active'
                };
                
                // 設定野獸類型和移動模式
                if (obstacle.type === 'beast') {
                    const beastSubtypes = ['tiger', 'dragon', 'lion', 'crocodile'];
                    obstacle.subtype = beastSubtypes[Math.floor(Math.random() * beastSubtypes.length)];
                    switch (obstacle.subtype) {
                        case 'tiger': // 左右移動，速度較快
                            obstacle.dx = (Math.random() > 0.5 ? 1 : -1) * 3;
                            break;
                        case 'dragon': // 緩慢左右移動
                            obstacle.dx = (Math.random() > 0.5 ? 1 : -1) * 1.5;
                            break;
                        case 'lion': // 靜止
                            obstacle.dx = 0;
                            break;
                        case 'crocodile': // 左右快速來回
                            obstacle.dx = (Math.random() > 0.5 ? 1 : -1) * 4;
                            break;
                    }
                } else if (obstacle.type === 'trap') {
                    // 設定陷阱類型
                    const trapSubtypes = ['spikes', 'pit', 'water', 'woods'];
                    obstacle.subtype = trapSubtypes[Math.floor(Math.random() * trapSubtypes.length)];
                } else if (obstacle.type === 'bomb') {
                    // 設定炸彈參數
                    obstacle.fuseTime = Math.random() * 4 + 4;
                    obstacle.spawnTime = Date.now();
                }

                obstacles.push(obstacle);
            }

            // 繪製所有障礙物
            function drawObstacles() {
                obstacles.forEach(drawObstacle);
            }

            // 更新遊戲狀態（主遊戲迴圈）
            function updateGame() {
                if (!isGameRunning) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 更新玩家位置
                player.x += player.dx;

                // 玩家邊界檢查
                if (player.x < 0) {
                    player.x = 0;
                }
                if (player.x + player.width > canvas.width) {
                    player.x = canvas.width - player.width;
                }

                // 更新障礙物位置並檢查碰撞
                obstacles.forEach((obstacle) => {
                    // 障礙物繼續向下移動
                    obstacle.y += obstacleSpeed;

                    // 若是野獸，則更新其水平位置
                    if (obstacle.type === 'beast') {
                        obstacle.x += obstacle.dx;
                        if (obstacle.x + obstacle.width > canvas.width || obstacle.x < 0) {
                            obstacle.dx *= -1;
                        }
                    } else if (obstacle.type === 'bomb') {
                        // 檢查炸彈是否爆炸
                        if (obstacle.state === 'active' && (Date.now() - obstacle.spawnTime) / 1000 >= obstacle.fuseTime) {
                            // 炸彈狀態設為爆炸中
                            obstacle.state = 'exploding';
                            obstacle.explosionStartTime = Date.now();
                            
                            const dx = Math.abs((player.x + player.width / 2) - (obstacle.x + obstacle.width / 2));
                            const dy = Math.abs((player.y + player.height / 2) - (obstacle.y + obstacle.height / 2));
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < bombBlastRadius) {
                                endGame(false);
                            }
                        }
                    }

                    // 碰撞偵測，只在非爆炸狀態下進行
                    if (obstacle.state !== 'exploding' &&
                        player.x < obstacle.x + obstacle.width &&
                        player.x + player.width > obstacle.x &&
                        player.y < obstacle.y + obstacle.height &&
                        player.y + player.height > obstacle.y
                    ) {
                        endGame(false);
                    }

                    // 檢查是否通過障礙物
                    if (obstacle.y > canvas.height && !obstacle.passed) {
                        obstacle.passed = true;
                        passedObstaclesCount++;
                        obstaclesPassedDisplay.textContent = passedObstaclesCount;
                    }
                });

                // 移除離開畫布的障礙物，或已結束爆炸動畫的炸彈
                obstacles = obstacles.filter(obstacle => {
                    if (obstacle.state === 'exploding') {
                        // 如果是爆炸中，只有當動畫結束後才移除
                        return Date.now() - obstacle.explosionStartTime < explosionDuration;
                    } else {
                        // 否則，只移除已離開畫布的物件
                        return obstacle.y < canvas.height + obstacle.height;
                    }
                });

                // 繪製玩家和障礙物
                drawPlayer();
                drawObstacles();

                // 檢查關卡進度
                if (passedObstaclesCount >= obstaclesPerLevel) {
                    if (currentLevel < 10) {
                        nextLevel();
                    } else {
                        endGame(true);
                    }
                }
            }

            // 開始遊戲
            function startGame() {
                isGameRunning = true;
                startButton.style.display = 'none';
                gameStatus.textContent = '';
                
                // 重置所有遊戲狀態
                currentLevel = 1;
                passedObstaclesCount = 0;
                obstaclesPerLevel = 10;
                obstacleSpeed = 2;
                obstacleGenerationRate = 1200;
                obstacles = [];
                
                player.x = (canvas.width / 2) - (player.width / 2);
                player.dx = 0;

                // 更新UI
                levelDisplay.textContent = currentLevel;
                obstaclesPassedDisplay.textContent = passedObstaclesCount;
                totalObstaclesDisplay.textContent = obstaclesPerLevel;

                gameInterval = setInterval(updateGame, 1000 / 60);
                obstacleGenerationInterval = setInterval(createObstacle, obstacleGenerationRate);
            }

            // 進入下一關
            function nextLevel() {
                isGameRunning = false;
                clearInterval(gameInterval);
                clearInterval(obstacleGenerationInterval);

                currentLevel++;
                passedObstaclesCount = 0;
                obstaclesPerLevel += 10;
                obstacleSpeed += 0.5;
                obstacleGenerationRate = Math.max(800, obstacleGenerationRate - 80);

                // 更新UI
                levelDisplay.textContent = currentLevel;
                obstaclesPassedDisplay.textContent = passedObstaclesCount;
                totalObstaclesDisplay.textContent = obstaclesPerLevel;

                gameStatus.textContent = `恭喜您通過第 ${currentLevel - 1} 關！`;
                
                setTimeout(() => {
                    gameStatus.textContent = `第 ${currentLevel} 關！準備！`;
                    obstacles = [];
                    setTimeout(() => {
                        isGameRunning = true;
                        gameInterval = setInterval(updateGame, 1000 / 60);
                        obstacleGenerationInterval = setInterval(createObstacle, obstacleGenerationRate);
                    }, 1000);
                }, 2000);
            }

            // 遊戲結束
            function endGame(win) {
                isGameRunning = false;
                clearInterval(gameInterval);
                clearInterval(obstacleGenerationInterval);
                startButton.style.display = 'block';

                if (win) {
                    gameStatus.textContent = `恭喜您！成功挑戰所有關卡！`;
                } else {
                    gameStatus.textContent = `遊戲結束！您在第 ${currentLevel} 關失敗了。`;
                }
            }

            // 鍵盤事件監聽器（左右鍵移動）
            document.addEventListener('keydown', (e) => {
                if (!isGameRunning) return;
                if (e.code === 'ArrowLeft') {
                    player.dx = -playerSpeed;
                } else if (e.code === 'ArrowRight') {
                    player.dx = playerSpeed;
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                    player.dx = 0;
                }
            });

            // 開始按鈕事件監聽器
            startButton.addEventListener('click', startGame);
        };
    </script>
</body>
</html>